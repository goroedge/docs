---
title: "Sed [d D p P]"
date: 2024-11-19T14:19:25+03:00
draft: false
description: 
noindex: false
featured: false
pinned: false
# comments: false
series:
  - regex
categories:
  - blog
tags:
  - sed
  - find
  - posix
images:
  - sed2.png
weight: 99
authors:
  - ra

# menu:
#   main:
#     weight: 100
#     params:
#       icon:
#         vendor: bs
#         name: book
#         color: '#e24d0e'
---

Примеры использования поисковых запросов POSIX с потоковым редактором SED

<!--more-->
{{< bs/alert info >}}
Потоковый редактор SED. Обзор команд d/D/p/P/l
{{< /bs/alert >}}


## Примеры с редактором SED
### d
Удаляет строки с результатом поиска
```shell
╭─edge@bsd in ~ 
╰$ seq 10 | sed -E  '1,3d;5d'
4
6
7
8
9
10
```

Удалит строки с 1-й по 3-ю и 5-ю
```shell
╭─edge@bsd in ~ 
╰$ seq 10 | sed -E  '2,$d'   
1
```

а этот удалит со 2-й до последней.

### D
Сделаю файл для тренировок
```shell
╭─edge@bsd in ~ 
╰$ >b.txt
aaa aa ddd aaa 
bbb bbb bbbbbbb bb

ccc ccccc ccc cccccc

iii iiii iiiiii ii
^Z
```

Пока не понял, но по умолчанию работает как и `d`
Одно могу сказать, что для совместимости с FreeBSD нужно использовать только нотацию `i\` и на новой строке текст.
```shell
╭─edge@bsd in ~ 
╰$ sed -E '=;D' b.txt  
1
2
3
4
5
6
```
Я понимаю, что `=` добавляет номер строки, но `D` просто убивает следующую строку с текстом, так как в ней есть перевод строки `\n`. Вообще эту тему нужно понимать на уровне буферов в которых работает SED. Про это я расскажу в статье про команды [`h H g G x`]({{% relref "/blog/regex/sed3" %}}). 

{{< bs/alert secondary >}}
d - очищает буфер редактирования по указанному адресу, а D очищает буфер редактирования по указанному адресу если там есть символ \n
{{< /bs/alert >}}

в следующих примерах, постараюсь больше уделить внимания этим командам именно в концепции работы буферов.

### n и N

понимай буквально:
`n` --- выведет следующую строку после паттерна
`N` --- выведет строку паттерна и следующую строку

```shell
╭─edge@bsd in ~ 
╰$ seq 20 | sed -En '/[27]/{n;p;}'  

3
8
13
18
```
и
```shell
╭─edge@bsd in ~ 
╰$ seq 20 | sed -En '/[27]/{N;p;}' 

2
3
7
8
12
13
17
18
```
без `p` не работает

### p и P

печатает результат

`p` --- напечатает все, что затронул паттерн
`P` --- напечатает строку, где сработал паттерн до символа `\n`
```shell
╭─edge@bsd in ~ 
╰$ seq 20 | sed -En '/[27]/{N;p;}'

2
3
7
8
12
13
17
18

и так до \n

╭─edge@bsd in ~ 
╰$ seq 20 | sed -En '/[27]/{N;P;}'

2
7
12
17

```

### l

напечатает выходной результат как есть с символом окончания строки
```shell
╭─edge@bsd in ~ 
╰$ seq 20 | sed -En '/[27]/{l;}'  

2$
7$
12$
17$
20$
```
Это шикарный пример на комплексную работу опций:
```shell
╭─edge@bsd in ~ 
╰$ seq 8 | sed -En '/[27]/{=;N;N;i\
start->
a\
:end
p;}'
2
start->
2
3
4
:end
7
```

1. Знак `=` выводит номер строки
2. Команда `i\` --- выводит `start->`
3. Команда `N;N;` выводит следующие два строки из входного потока
4. Команда `p` --- разрешает все это дело печатать.

Обзор документации по SED в разделе **Справочник**. [Подробнее..]({{% relref "/docs/linux/sed" %}})
