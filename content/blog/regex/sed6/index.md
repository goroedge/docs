---
title: "Sed Метки и обзор команд [s y b t ]"
date: 2024-11-24T10:24:06+03:00
draft: true
description: 
noindex: false
featured: false
pinned: false
# comments: false
series:
  - regex
categories:
  - blog
tags:
  - sed
  - find
  - posix
images:
  - sed6.png
weight: 103
authors:
  - ra
---

Примеры использования поисковых запросов POSIX

<!--more-->

{{< bs/alert info >}}
	Потоковый редактор SED. Метки и обзор команд [s y b t ]
{{< /bs/alert >}}
## Примеры с редактором SED

### Еще флаги для команды `s`

`s` --- это очень милая команда которая все заменяет по шаблону.

В кратце: `[adr1,][adr2]s/Что меняем/на что меняем/flags`

 - [adr1] и [adr2] --- это могут быть буквально номера строк с --- по, хоть цифрами, хоть маской для поиска:
 - `что меняем` --- это реальный текст который будет заменен
 - `на что меняем` --- такой же реальный текст, которым заменим образец.
 
Например:

```shell
sed -n /love/,/life/s/plus/minus/g
```
т.е. буквально: найти строку где есть слово `love` и от нее до строки где есть `life` все `plus` заменить на `minus`.

а это флаги у команды `s`:

 - N --- номер по счету позиции замены
 - p --- выводить в выходной поток только измененные строки
 - g --- замены всех патернов
 - i - I --- замена не чувствительная к регистру

### y --- транслитерация символов

буквально пишем шифровки: `y/abc/123/` вот так это выглядит. Т.е. везде где встретим a -> поменять на 1, b на 2, c на 3. И без вариантов. 

### работа с метками

Есть немного разный синтаксис в многострочной записи и однострочной.

Чем приятна многострочная, что каждую команду пишем в новой строке и нет никаких проблем.
: метка --- поставить метку
b метка --- перейти безоговорочно по метке
t метка --- перейти по метке, если выполнена замена

```shell
╭─edge@bsd in ~/tmp 
╰$ seq 12 | sed -E -n '{=      
: f
s/[47]/Y/p
t f
y/12356890/abcdefgh/
};p' > 4.out
1
a
2
b
3
c
4
Y
Y
5
d
6
e
7
Y
Y
8
f
9
g
10
ah
11
aa
12
ab
```
В однострочной: обязательно метку выделить в отдельную команду через `-e:u` --- это я типа поставил метку `u`.

А когда переходим по метке, тоже свои заморочки, что приходится закрывающую скобку выносить в отдельный `-e'{'`.
```shell
╭─edge@bsd in ~/tmp 
╰$ printf "---\nbbb\nccc\nddd\n" | sed -n -e'{h;1!p;}' -e:u -e'{n;p;g;p;bu' -e'}'
bbb
---
ccc
---
ddd
---
```
В этом примере я лихо первым параметром подчеркнул все остальные строки текста.

### Пример печати номера строк перед текстом в файле.

На самом деле это пример работы с буфером удержания. Ему я еще песни допою.
```shell
╭─edge@bsd in ~/tmp 
╰$ sed -En '/[[:digit:]]{1,2}/{N
s/\n/->/gp
}' <4.out | sed -En '/(.*)/s//\1:=/p'
1->a:=
2->b:=
3->c:=
4->Y:=
5->d:=
6->e:=
7->Y:=
8->f:=
9->g:=
10->ah:=
11->aa:=
12->ab:=
13->ac:=
14->1Y:=
15->ad:=
16->ae:=
17->1Y:=
18->af:=
19->ag:=
20->bh:=
```

### z --- очищает шаблон

