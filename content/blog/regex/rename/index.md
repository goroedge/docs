---
title: "Как переименовать много файлов?"
date: 2024-11-20T15:59:05+03:00
draft: false
description: 
noindex: false
featured: false
pinned: false
# comments: false
series:
  - regex
categories:
  - blog
tags:
   - posix
   - rename file
   - find
   - sed
   - xargs
images:
  - rename.png
weight: 90
authors:
  - ra
# menu:
#   main:
#     weight: 100
#     params:
#       icon:
#         vendor: bs
#         name: book
#         color: '#e24d0e'
---

Очень интересное занятие в однострочной команде переименовать все файлы по маске в REGEX

<!--more-->

## Переименовать очень много файлов

{{< bs/alert danger >}}
Тема важна сама по себе как супер инструмент для обработки больших объемов файлов с помощью команд: find, sed и xargs
{{< /bs/alert >}}

Каждая команда заслуживает отдельного внимания и у этой статьи будет продолжение в виде различных обзоров документации:

 - для ознакомления с синтаксисом команды FIND ([Подробнее..]({{% relref "/docs/linux/find" %}}))
 - для ознакомления с синтаксисом команды SED  ([Подробнее..]({{% relref "/docs/linux/sed" %}}))
 - для ознакомления с синтаксисом команды XARGS  ( {{< bs/alert-link "Подробнее.." "https://www.opennet.ru/man.shtml?topic=xargs&category=1&russian=1" >}})
 
### Имеем на старте

```shell
╭─edge@edge-manjaro in ~/data/sites/hb3/content/gallery/osen on main ✘ (origin/main +6 -1)
╰$ ls
10.jpg                            photo_1_2024-11-17_11-28-42.jpg   photo_4_2024-11-17_11-28-42.jpg  photo_8_2024-11-17_11-28-42.jpg
index.md                          photo_12_2024-11-17_11-28-42.jpg  photo_5_2024-11-17_11-28-42.jpg  photo_9_2024-11-17_11-28-42.jpg
index.md~                         photo_2_2024-11-17_11-28-42.jpg   photo_6_2024-11-17_11-28-42.jpg
photo_11_2024-11-17_11-28-42.jpg  photo_3_2024-11-17_11-28-42.jpg   photo_7_2024-11-17_11-28-42.jpg

```
и таких директорий очень много и они находятся на разных уровнях вложенности. Переименовывать по одному вручную не очнь утешительное занятие.

Поэтому!
{{< bs/alert info >}}


Проделав исследовательскую работу и влюбившись во все вышеперечисленные приложения, я понял, что с их помощью можно сделать с файловой системой хоть на локальном, хоть на удаленном компьютере все что угодно!
{{< /bs/alert >}}

### Команды в FIND

```shell
find . -type f -regextype posix-extended -regex '.*photo_[[:digit:]]{,2}_.*\.jpg' | sed -En 's/((.*)photo_([[:digit:]]{,2})_.*\.jpg)/\1 \2\3.jpg/p' | xargs -p -l1 mv $1 $2 
```

их не так много:

 - {{< icons/icon vendor=bootstrap name=1-circle-fill color=red >}} --- `.` точка нам задает исходный путь в файловой системе, откуда начинаем поиск. Можно было задать `./` или любой другой путь. Ограничений по вложенности не ставлю, поэтому будет искать во всех вложенных каталогах.
 - {{< icons/icon vendor=bootstrap name=2-circle-fill color=red >}} --- `-regextype posix-extended` включаю расширенный режим синтаксиса в регулярных выражениях. Не спрашивайте зачем я это делаю, делаю, потому-что мне нравится расширенный синтаксис.
 - {{< icons/icon vendor=bootstrap name=3-circle-fill color=red >}} --- `-type f` устанавливаю тип поиска. Искать буду только файлы.
 - {{< icons/icon vendor=bootstrap name=4-circle-fill color=red >}} --- `-regex` даю команду, что искать буду с помощью регулярного выражения и дальше пойдет в апострофах само регулярное выражение.
 - {{< icons/icon vendor=bootstrap name=5-circle-fill color=red >}} --- `'.*photo_[[:digit:]]{,2}_.*\.jpg' ` регулярное выражение, где:
   - `.*` какое-то большое количество символов до слова `photo`. Для справки `Find` всегда возвращает результат с учетом всего пути файла и начинает его с `./`.
   - `photo_` это маска файлов,которые меня будут интересовать
   - `[[:digit:]]{,2}` --- можно было не ставить, но для надежности и отсева мусора. В файле, сразу после `_` и перед другим `_` должно быть не больше двух цифр. Правильно наверно надо было сделать {1,2}, т.е. от одной до двух. Но у меня цифра,хотя бы одна есть.
   - `_` --- подчеркивание и еще какое-то большое количество символов `.*` до...
   - `\.jpg` --- именно точка и jpg, чем и заканчивается файл.
 
Весь этот поток передаем через команду `|` в команду `sed`

### Команды SED

В командах SED запрос практически повторяется, но он уже работает только с тем, что получили из Find. Поэтому задача расставить правильно переменные у меня их 3.

 - {{< icons/icon vendor=bootstrap name=1-circle-fill color=red >}} --- `((.*)photo_([[:digit:]]{,2})_.*\.jpg)` все выражение переменная 1.
 - {{< icons/icon vendor=bootstrap name=2-circle-fill color=red >}} --- `((.*)photo_...` путь к файлу это будет переменная 2
 - {{< icons/icon vendor=bootstrap name=3-circle-fill color=red >}} --- `([[:digit:]]{,2})` и номер после слова `photo_`, который и будем использовать в качестве имени будущего файла. Это будет переменная 3.
 - {{< icons/icon vendor=bootstrap name=4-circle-fill color=red >}} --- в качестве опций SED установим `-E` --- включает расширенный режим `POSIX` и `-n` выдает во внешний поток, только строки, удовлетворяющие запросу.
 - {{< icons/icon vendor=bootstrap name=5-circle-fill color=red >}} --- команды regex в SED:
   + `s/источник/замена/` --- выполнить замену текста
   + `\1 \2\3.jpg` --- склеить строку из первоначального наименования файла вместе с полным путем на диске, пробел и новое имя файла, состоящее из пути его хранения(\2) и нового имени (\3) и добавим .jpg в конце.
   + `p` --- напечатать результат в выходной поток. 
 
SED нам подготовит две переменные, разделенные пробелом. Это старое имя файла и новое имя файла и все это через команду `|` мы передаем дальше в команду `XARGS`.

### Команды XARGS

Xargs прекрассная комана для передачи любого количества аргументов в другую программу. Собственно нам это и нужно.

 - {{< icons/icon vendor=bootstrap name=1-circle-fill color=red >}} --- `-p` ключ указывает чтобы программа выдавала запрос на выполнение каждой обрабатываемой строки.
 - {{< icons/icon vendor=bootstrap name=2-circle-fill color=red >}} --- `l1` ключ указывает,что передават будем по одной строке.
 - {{< icons/icon vendor=bootstrap name=3-circle-fill color=red >}} --- `mv` запускать будем команду `mv`, которая, собственно и переименовывает файлы.
 - {{< icons/icon vendor=bootstrap name=4-circle-fill color=red >}} ---  `$1` и `$2` собственно параметры команды `mv` --- старое имя и новое имя файла.
 
Запускаем! Подтверждаем каждую строчку! И вуаля!
```shell
╭─edge@edge-manjaro in ~/data/sites/hb3/content/gallery/osen on main ✘ (origin/main +6 -1)
╰$ find . -type f -regextype posix-extended -regex '.*photo_[[:digit:]]{,2}_.*\.jpg' | sed -En 's/((.*)photo_([[:digit:]]{,2})_.*\.jpg)/\1 \2\3.jpg/p' | xargs -p -l1 mv $1 $2 
mv ./photo_2_2024-11-17_11-28-42.jpg ./2.jpg?...y
mv ./photo_3_2024-11-17_11-28-42.jpg ./3.jpg?...y
mv ./photo_4_2024-11-17_11-28-42.jpg ./4.jpg?...y
mv ./photo_5_2024-11-17_11-28-42.jpg ./5.jpg?...y
mv ./photo_6_2024-11-17_11-28-42.jpg ./6.jpg?...y
mv ./photo_7_2024-11-17_11-28-42.jpg ./7.jpg?...y
mv ./photo_8_2024-11-17_11-28-42.jpg ./8.jpg?...y
mv ./photo_9_2024-11-17_11-28-42.jpg ./9.jpg?...y
mv ./photo_11_2024-11-17_11-28-42.jpg ./11.jpg?...y
mv ./photo_12_2024-11-17_11-28-42.jpg ./12.jpg?...y
mv ./photo_1_2024-11-17_11-28-42.jpg ./1.jpg?...y
```

Получаем шикарный результат, как и задумывали!

```shell
╭─edge@edge-manjaro in ~/data/sites/hb3/content/gallery/osen on main ✘ (origin/main +6 -1)
╰$ ls
10.jpg  11.jpg  12.jpg  1.jpg  2.jpg  3.jpg  4.jpg  5.jpg  6.jpg  7.jpg  8.jpg  9.jpg  index.md  index.md~
```
